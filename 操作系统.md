# 一、操作系统



## 1. 操作系统的功能和目标

### 1.1 作为系统资源的管理者



![image-20211031105738469](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031105738469.png)



### 1.2 作为用户和计算机硬件之间的接口

![image-20211031110105880](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031110105880.png)

![image-20211031110202180](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031110202180.png)

![image-20211031111840046](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031111840046.png)

#### 1.2.1 命令接口![image-20211031110316714](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031110316714.png)

![image-20211031110446608](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031110446608.png)



#### 1.2.2 程序接口

> 用户只能通过程序程序间接调用，不能直接使用

![image-20211031111732971](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031111732971.png)



### 1.3 作为最接近硬件的层次

![image-20211031112434217](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211031112434217.png)





## 2.操作系统的特征

![image-20211105152412502](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105152412502.png)

### 2.1	并发

> 并发：
>
> ​	两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
>
> 并行：
>
> ​	两个或多个事件在同一时刻同时发生

![image-20211105152940335](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105152940335.png)

![image-20211105153233035](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105153233035.png)



### 2.2	共享



#### 2.2.1	互斥共享

> 在系统中一个时间段只能一个进程进行资源的访问
>
> ![image-20211105154242558](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105154242558.png)



#### 2.2.2	同时共享

> 允许一个时间段内多个进程“==同时==”进行资源的访问
>
> ![image-20211105153941746](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105153941746.png)
>
> ![image-20211105154303035](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105154303035.png)



#### 2.2.3	并发和共享的关系

![image-20211105154716145](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105154716145.png)



### 2.3	虚拟

![image-20211105175353255](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105175353255.png)



### 2.4	异步

![image-20211105180109288](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211105180109288.png)





## 3. 操作系统的运行机制和体系结构



![image-20211106135501801](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106135501801.png)

### 3.1	指令

**特权指令**

> 如内存清0指令这种比较危险的指令，需要特权

**非特权指令**

> 如加减乘除这种没有危险的指令，不需要特权



### 3.2	处理器状态

![image-20211106133821538](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106133821538.png)

### 3.3	两种程序

![image-20211106134020699](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106134020699.png)



### 3.4	操作系统内核

![image-20211106134640536](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106134640536.png)

### 3.5	操作系统的体系结构

**大内核：**

> 有的操作系统把进程管理、存储器管理、设备管理等功能归为操作系统内核，这样内核就变大了，就叫大内核

**微内核：**

> 有的操作系统把进程管理、存储器管理、设备管理等功能不归为操作系统内核，就叫微内核

![image-20211106135108665](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106135108665.png)



**区别：**

![image-20211106140500280](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106140500280.png)



## 4. 中断



### 4.1	中断的作用

![image-20211106144632465](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106144632465.png)



### 4.2	中断的分类

![image-20211106151740653](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106151740653.png)

**外中断的处理过程：**

![image-20211106151848981](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211106151848981.png)



## 5.系统调用



### 5.1	什么是系统调用？有什么作用？



> 系统中的各种共享资源都由操作系统统一管理，应用程序想要访问系统资源，就得通过系统调用的方式（**操作系统给应用程序提供的接口**）

![image-20211208175333857](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211208175333857.png)



**举例：**

![image-20211208174720629](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211208174720629.png)



### 5.2	系统调用与库函数的区别



> 应用程序需要通过库函数实现某些功能，而有的库函数涉及到共享资源的请求因此该库函数需要封装系统调用

![image-20211208180522767](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211208180522767.png)



### 5.3	系统调用背后的过程

![image-20211208181934600](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211208181934600.png)







---



# 二、进程



##  2.1	进程的简要介绍



### 2.1.1	进程



**进程控制块（PCB）：**

> 进程控制块记录了进程的相关信息，如程序代码的存放位置等



**程序段：**

> 存放程序代码的



**数据段：**

> 程序运行时的数据放在数据段中



**进程实体：**

> **进程控制块、程序段、数据段构成了进程实体**。PCB是进程实体的唯一标志。一般来说可以把进程实体认为是进程（但并不完全相同）
>
> ![image-20211209153008725](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209153008725.png)



**进程与进程实体的区别：**

> 进程是进程实体的运行过程，是系统资源分配和调度的一个独立单位
>
> ![image-20211209152203559](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209152203559.png)





**进程实体在内存结构如图：**

![image-20211209152421523](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209152421523.png)



### 2.1.2	进程的组织



![image-20211209153358125](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209153358125.png)



**进程的组织方式：**

​	1.链接方式、2.索引方式

> 这俩方式差不多，一个是通过队列的方式来存储不同状态的PCB，一个是通过建立多个表的方式来存储不同状态的PCB。操作系统持有多个队列/表的指针



#### 2.1.2.1	链接方式

![image-20211209154657298](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209154657298.png)

#### 2.1.2.2	索引方式

![image-20211209154845511](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209154845511.png)



#### 2.1.2.3	进程的特征



![image-20211209155528866](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209155528866.png)





### 2.1.3	进程的状态 

> 分为新建态、就绪态、运行态、阻塞态、终止态
>
> 就绪态：已经具备运行条件，由于没有空闲的cpu，所以处于等待状态（**进程已经拥有除了cpu之外的所有需要的资源**）
>
> 阻塞态：因等待某一些事情而暂时不能运行（如等待系统分配打印机资源）
>
> 创建态/新建态：进程正在被创建，操作系统为进程分配资源、初始化PCB
>
> 终止态/结束态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB



**进程状态之间的转换：**

![image-20211209163202227](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211209163202227.png)



### 2.1.4	进程控制



**什么是进程控制？**

![image-20211210151031662](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210151031662.png)



![image-20211210151533638](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210151533638.png)

原语：

> 原语特点：处于操作系统的最底层，最近接硬件是一种特殊的程序。在执行期间不能中断，采用关中断指令和开中断指令来实现
>
> 关中断、开中断需要在核心态，原语运行在核心态

![image-20211210152024675](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210152024675.png)



![image-20211210153912278](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210153912278.png)

![image-20211210153927692](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210153927692.png)

![image-20211210154046714](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210154046714.png)

![image-20211210154127124](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210154127124.png)

![image-20211210154217106](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210154217106.png)



### 2.1.5	进程通信

> 一个进程不能直接访问其他进程的地址空间

![image-20211210181515952](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210181515952.png)





#### 2.1.5.1	共享存储

![image-20211210182142820](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210182142820.png)



#### 2.1.5.2	消息传递

> 进程间的数据交换一格式化的消息为单位。进程通过操作系统提供的“发送消息”/“接收消息”两个原语进行数据交换
>
> ​	消息传递分为直接通信方式、间接通信方式两种
>
> **消息结构：**
>
> ![image-20211210183124339](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210183124339.png)



**直接通信方式：**

> 进程1通过发送原语将**消息直接挂到接收进程的消息缓冲队列上**，进程2通过接收原语将消息缓冲队列的消息取走
>
> ![image-20211210183302785](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210183302785.png)



**间接通信方式：**

> 进程1通过发送原语将消息发送到信箱中，进程2再通过接收原语将消息从信箱中取出
>
> ![image-20211210183226500](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210183226500.png)
>
> ![image-20211210194718904](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210194718904.png)





#### 2.1.5.3	管道通信



![image-20211210182555739](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211210182555739.png)





### 2.1.6	进程同步



**异步性：**

> 各并发执行的进程以各自独立的、不可预知的速度向前推进

同步：

> 有些时候需要进程之间要有对应的顺序而要进行制约
>
> ![image-20211216210314076](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216210314076.png)







### 2.1.7	进程互斥



![image-20211216210915308](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216210915308.png)

![image-20211216211359649](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216211359649.png)





**遵循的原则：**

![image-20211216212434548](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216212434548.png)



#### 2.1.7.1	软件实现方法



##### 2.1.7.1	单标志法



**算法思想：**

> 进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予



![image-20211220181936678](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220181936678.png)





**缺点：**

![image-20211220182150320](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220182150320.png)



##### 2.1.7.2	双标志先检查



**算法思想：**

![image-20211220191047113](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220191047113.png)





**实现：**

![image-20211220191140924](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220191140924.png)





**缺点：**

> 有可能会使两个进程同时访问临界资源，这就违反了互斥的初衷

![image-20211220191224060](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220191224060.png)



##### 2.1.7.3	双标志后检查



**算法思想：**



![image-20211220193056274](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220193056274.png)





**实现：**



![image-20211220193132436](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220193132436.png)



**缺点：**

![image-20211220193221208](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220193221208.png)



##### 2.1.7.4	Peterson算法



**算法思想：**



![image-20211220194351624](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220194351624.png)





**实现：**



![image-20211220200201629](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220200201629.png)





**小缺点：**

> 没有让权等待，即使进不去临界区也要等时间片结束后才换别的进程

![image-20211220200256224](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220200256224.png)





#### 2.1.7.2	硬件实现方法



##### 2.1.7.2.1	中断屏蔽方法



> 开中断和关中断只对执行这个指令的处理机有效

![image-20211220201219966](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220201219966.png)

##### 2.1.7.2.2	TestAndSet（TS指令/TSL指令）

![image-20211220201946094](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220201946094.png)

##### 2.1.7.2.3	Swap指令（XCHG指令）



![image-20211220202855144](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211220202855144.png)





### 2.1.8	信号量机制



> **双标志先检查法、和双标志后检查法**之所以会出现安全隐患说到底是因为**检查和上锁不能一气呵成**，因此可以用**原语对信号量进行操作**进而实现进程互斥、进程同步
>
> 信号量：表示系统中某种资源的数量，它是一个变量。

![image-20211221141451143](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221141451143.png)





#### 2.1.8.1	整型信号量



> 会出现忙等而不是让权等待

![image-20211221143139930](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221143139930.png)



#### 2.1.8.2	记录型信号量



> 实现了让权等待

![image-20211221145315538](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221145315538.png)



**总结：**

![image-20211221150724357](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221150724357.png)





#### 2.1.8.3	信号量机制实现进程互斥/同步



> 互斥问题信号量初始值设为1，同步问题信号量初始值设为0/n



**信号量机制实现进程互斥：**

> 将临界区看成一种互斥的资源，用信号量机制就可以实现进程互斥访问临界区

![image-20211221154255278](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221154255278.png)





**回忆进程同步：**

![image-20211221154755116](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221154755116.png)



**信号量机制实现进程同步：**

![image-20211221155429664](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221155429664.png)



**信号量机制实现前驱关系：**

![image-20211221161433917](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221161433917.png)



### 2.1.9	生产者与消费者问题



**问题描述：**

![image-20211221163034033](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221163034033.png)



**实现：**

![image-20211221172121636](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221172121636.png)



![image-20211221171847456](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211221171847456.png)







**多生产多消费：**

> 在这里指的是多种生产者和多种消费者，而不是多个生产者和多个消费者



**问题描述：**

![image-20211222130658359](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222130658359.png)





**实现**：

![image-20211222131024090](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222131024090.png)





**如果去掉互斥信号量呢？**





![image-20211222131638778](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222131638778.png)





**为什么？**



![image-20211222131657957](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222131657957.png)





**如果缓冲区（盘子=2）呢？**

![image-20211222132316094](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222132316094.png)



**总结：**



![image-20211222132515065](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222132515065.png)



![image-20211222133208859](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222133208859.png)





### 2.1.10	吸烟者问题



![image-20211222160910313](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222160910313.png)





**实现：**

![image-20211222161907214](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222161907214.png)





**总结：**

![image-20211222162350913](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211222162350913.png)





### 2.1.11	读者-写者问题



**问题引入：**

![image-20211223100316548](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223100316548.png)





**问题分析：**

![image-20211223100409155](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223100409155.png)





**实现：**

![image-20211223101457415](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223101457415.png)





**改进：**

![image-20211223102516420](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223102516420.png)





**总结：**

![image-20211223102728115](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223102728115.png)





### 2.1.12	哲学家进餐问题



**问题引入：**

![image-20211223103358093](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223103358093.png)





**实现：**

![image-20211223105834956](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223105834956.png)





**总结：**

![image-20211223110111142](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223110111142.png)





### 2.1.13	管程



**引入原因：**

> 在编写程序时写复杂的p、v操作很容易出错，因此引入了管程来实现进程同步/互斥



![image-20211223180158144](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223180158144.png)





> 管程内的过程封装好了p、v操作实现了进程同步，编译器实现了进程互斥。因此程序员只需要调用方法即可

![image-20211223181040799](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223181040799.png)



**总结：**

![image-20211223181744909](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223181744909.png)





## 2.2	线程



### 2.2.1	线程的概念

![image-20211211192032551](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211192032551.png)



> 引入线程后：进程内的线程也可以并发，提高了并发度

![image-20211211192700521](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211192700521.png)





#### 2.2.1.1	进程与线程的区别

![image-20211211193918289](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211193918289.png)





**线程相关事宜：**

> 1. **线程是处理机调度的单位**
> 2. 每个线程都有一个线程ID、线程控制块（TCB）
> 3. **线程几乎不拥有系统资源**
> 4. **同一进程的不同线程共享进程的资源**
> 5. 因为共享内存地址空间，同一进程中的线程间通信无需系统干预
> 6. 同一进程中的线程切换，不会引起进程切换
> 7. 不同进程中的线程切换，会引起进程切换
> 8. 切换同进程内的线程，系统开销小
> 9. 切换进程，系统开销大



#### 2.2.1.2	线程的实现方式



**用户级线程：**

![image-20211211205011235](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211205011235.png)



**内核级线程：**

![image-20211211205544178](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211205544178.png)





 **同时支持用户级线程和内核级线程的系统中，可以采用二者组合的方式：**

![image-20211211205941499](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211205941499.png)





#### 2.2.1.3	多线程模型



**多对一模型：**

![image-20211211213218229](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211213218229.png)





**一对一模型：**

![image-20211211213713186](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211213713186.png)





**多对多模型：**

 ![image-20211211213813457](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211211213813457.png)





## 2.3	调度



### 2.3.1	处理机调度



#### 2.3.1.1	基本概念

![image-20211212155143159](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212155143159.png)

> 从**就绪队列**中按照**一定的算法**去**选择一个进程**并将处理机分配给它，以实现进程的并发执行



#### 2.3.1.2	三个层次



**高级调度：**

![image-20211212155627789](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212155627789.png)

![image-20211212155646067](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212155646067.png)

![image-20211212155900068](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212155900068.png)



**中级调度：**

> 决定哪个挂起的进程被重新调入内存

![image-20211212160616103](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212160616103.png)





**低级/进程调度：**

![image-20211212161620764](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212161620764.png)

**三层调度的对比：**

![image-20211212161928251](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212161928251.png)



#### 2.3.1.3	挂起与七状态模型



![image-20211212161317218](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211212161317218.png)



### 2.3.2	进程调度



#### 2.3.2.1 	实机

![image-20211213133745047](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211213133745047.png)



![image-20211213133551497](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211213133551497.png)





#### 2.3.2.2	切换与过程

> 非抢占式：只允许进程主动放弃处理机，运行过程中不会先处理更急迫的任务
>
> 抢占式：一个进程在执行时，当有更紧迫的进程时会先处理这个更紧迫的进程

![image-20211213134019616](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211213134019616.png)







#### 2.3.2.3 	方式

![image-20211213134357275](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211213134357275.png)





### 2.3.3	调度算法的评价指标



![image-20211214201006874](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214201006874.png)



### 2.3.4	调度算法



#### 2.3.4.1	先来先服务FCFS

![image-20211214205235678](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214205235678.png)

![image-20211214204811616](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214204811616.png)





#### 2.3.4.2	短作业优先SJF/SPF



![image-20211214211830566](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214211830566.png)



**非抢占式：**

![image-20211214210006228](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214210006228.png)



**抢占式：**

![image-20211214210652538](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214210652538.png)

![image-20211214210853973](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214210853973.png)



**SJF注意事项：**

![image-20211214211402873](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214211402873.png)



#### 2.3.4.3	高响应比优先算法HRRN



**陈述FCFS、SJF的缺点：**

![image-20211214212027706](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214212027706.png)

> 服务时间就是运行时间

![image-20211214213802790](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214213802790.png)

![image-20211214213609195](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214213609195.png)





#### 2.3.4.4	三种算法总结



![image-20211214214029005](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211214214029005.png)



### 2.3.5	调度算法2



#### 2.3.5.1	时间片轮转RR



**例题：**

![image-20211216200336630](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216200336630.png)



**时间片为2的情况：**

![image-20211216194503736](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216194503736.png)

![image-20211216194535416](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216194535416.png)

![image-20211216194552326](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216194552326.png)





**时间片为5的情况：**

![image-20211216194814784](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216194814784.png)





**时间片不宜过大或过小：**



> 时间片过大有可能退化为先来先服务算法，响应时间变长，让用户等的太久
>
> 时间片过小进程频繁来回切换会花费大量开销

![image-20211216195244205](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216195244205.png)





#### 2.3.5.2	优先级调度算法



![image-20211216202142413](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216202142413.png)

**非抢占式的优先级算法：**

![image-20211216200924417](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216200924417.png)



**抢占式的优先级算法：**

![image-20211216201336744](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216201336744.png)





**补充说明：**

![image-20211216202016091](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216202016091.png)



#### 2.3.5.3	多级反馈队列



**问题引入**：

![image-20211216202423104](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216202423104.png)







![image-20211216203941903](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216203941903.png)



**例题：**

![image-20211216203358239](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216203358239.png)



#### 2.3.5.4	三种算法的总结

![image-20211216204505325](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211216204505325.png)





### 2.4	死锁



> 在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源**，**导致各进程都阻塞，都无法向前推进**



**死锁、饥饿、死循环的对比：**

![image-20211223185318095](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223185318095.png)





**发生死锁的必要条件：**



![image-20211223190607469](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223190607469.png)





**什么时候会发生死锁：**

![image-20211223191544842](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211223191544842.png)





**死锁的处理策略：**

1. 预防死锁
   1. 破坏死锁产生的四个必要条件中的一个或几个（静态策略）
2. 避免死锁
   1. 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）（动态策略）
3. 死锁的检测和解除
   1. 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁



**总结：**

​	前两者的处理是在发生死锁前就进行预防处理，第三个则是在发生死锁后进行处理





#### 2.4.1	死锁的预防



1. **破坏互斥条件**



![image-20211224121007811](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224121007811.png)



2. **破坏不可剥夺条件**

   ![image-20211224121532298](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224121532298.png)



3. **破坏请求和保持**

   ![image-20211224122150730](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224122150730.png)

   

4. **破坏循环等待条件**

![image-20211224122818782](C:/Users/李天帅/AppData/Roaming/Typora/typora-user-images/image-20211224122818782.png)



#### 2.4.2	避免死锁



**安全序列：**

> 所谓安全序列就是**如果系统按照这种序列分配资源，则每个进程都能顺利完成**。只要能找出一个安全序列，系统就是安全状态。当然，**安全序列可能有多个**
>
> ![image-20211224124404810](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224124404810.png)



**银行家算法：**

> 核心思想：
>
> ​	在进程提出资源申请时，**先预判此次分配是否会导致系统进入不安全状态**。如果会**进入不安全状态**，**就暂时不答应这次请求，让该进程先阻塞等待**。



![image-20211224130522105](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224130522105.png)



**求安全序列：**

> 通过安全性算法

![image-20211224130853868](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224130853868.png)







**银行家算法具体细节：**

![image-20211224132421369](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224132421369.png)



**银行家算法总结：**

![image-20211224132347743](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224132347743.png)





#### 2.4.3	死锁的检测和解除



**死锁的检测：**

![image-20211224135459331](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224135459331.png)



**检测方法：**



![image-20211224142758916](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224142758916.png)

![image-20211224142710927](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224142710927.png)



**死锁定理：**

> 如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁



**死锁解除：**

![image-20211224143458782](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224143458782.png)







# 三、内存



## 3.1	一些概念



**逻辑地址与物理地址**：

![image-20211224151342075](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224151342075.png)

![image-20211224151426920](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224151426920.png)





**在装入时期要实现逻辑地址到物理地址的转换：**

![image-20211224151630632](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224151630632.png)





### 3.1.1	装入的三种方式



#### 3.1.1.1	绝对装入



> 在**编译**的时候就得知道**装入模块要放到内存中的哪个位置**
>
> 缺点：只适用于单道程序环境

![image-20211224162833170](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224162833170.png)



#### 3.1.1.2	静态重定位/可重定位装入



> **装入时**对地址进行重定位，一次性将**逻辑地址变换为物理地址**
>
> 缺点：
>
> 1. 在一个**作业装入内存**时，**必须分配其要求的全部内存空间**，如果**没有足够的内存**，**就不能装入该作业**
> 2. 作业一旦**进入内存**后，**在运行期间就不能移动，也不能申请内存空间**，**否则作业一经移动，指令里面的物理地址就是错的**

![image-20211224163228023](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224163228023.png)





#### 3.1.1.3	动态重定位/动态运行时装入



![image-20211224163939913](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224163939913.png)



**装入内存：**

![image-20211224164047016](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224164047016.png)



**程序执行时：**

> **动态重定位的优点：**
>
> 1. 借助重定位寄存器可以使程序在内存中进行移动
> 2. 可将程序分配到不连续的存储区中
> 3. 在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存
> 4. 便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

![image-20211224164339275](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224164339275.png)





### 3.1.2	链接的三种方式



#### 3.1.2.1	静态链接



> 在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完成的可执行文件（装入模块），之久不再拆开。

![image-20211224165809433](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224165809433.png)



#### 3.1.2.2	装入时动态链接



> 将各目标模块装入内存时，边装入边链接的链接方式

![image-20211224170105576](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224170105576.png)



#### 3.1.2.3	运行时动态链接

> 在**程序执行中**需要该目标模块时，才对它进行链接。
>
> 优点：便于修改和更新，便于实现对目标模块的共享







## 3.2	内存管理的概念





![image-20211224175703625](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211224175703625.png)







### 3.2.1	内存空间的扩充



**背景：**

> 程序大小超过了物理内存总和



#### 3.2.1.1	覆盖技术



**思想：**

> 将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。



> 内存中分为**一个固定区**和**若干个覆盖区**。
>
> **常驻内存的段放在固定区**中，**调入后就不再调出**（**除非运行结束**）
>
> **不常用的段放在覆盖区**，需要用到时调入内存，用不到时调出内存



![image-20211225150403831](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225150403831.png)



#### 3.2.1.2	交换技术



**思想：**

> **内存空间紧张**时，系统**将内存中某些进程暂时换出外存**，把**外存中某些已具备运行条件的进程换入内存**（进程在内存与磁盘间动态调度）



**提出的三个问题：**

1. 应该在外存（磁盘）的什么位置保存被换出的进程？
2. 什么时候应该交换？
3. 应该换出哪些进程？



**解决上述三个问题：**



![image-20211225163337295](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225163337295.png)





**覆盖与交换区别：**

![image-20211225163813468](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225163813468.png)





#### 3.2.1.3	虚拟存储技术









### 3.2.2	内存空间的分配与回收



> 连续分配：
>
> ​	指为用户进程分配的必须是一个连续的内存空间。

#### 3.2.2.1	连续分配管理方式



##### 3.2.2.1.1	单一连续分配



![image-20211225165249359](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225165249359.png)



##### 3.2.2.1.2	固定分区分配



![image-20211225182547644](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225182547644.png)





![image-20211225183955063](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225183955063.png)



##### 3.2.2.1.3	动态分区分配



![image-20211225184310293](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225184310293.png)





**动态分区相关的三个问题：**

1. 系统要用什么样的数据结构记录内存的使用情况？

   ![image-20211225190307584](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225190307584.png)

   

2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

   ![image-20211225190440194](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225190440194.png)

   

   

   **动态分区分配算法：**

   

   1. **首次适应算法**

      

      **算法思想：**

      > 每次都从低地址开始查找，找到第一个能满足大小的空闲分区

      

      **实现**：

      > 空闲分区以抵制递增的次序排列。每次分配内存时顺序查找空闲分区链/表，找到大小能满足要求的第一个空闲分区。

      

      进程5需要15MB资源

      

      ![image-20211225205505312](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225205505312.png)

      分配后：

      ![image-20211225210037407](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225210037407.png)

      

   2. **最佳适应算法**

      

      **算法思想：**

      > 优先使用更小的空闲区，将更大的空闲区留给大进程

      

      **实现：**

      > 空闲分区**按容量递增次序链接**。每次分配内存时顺序查找空闲分区链/表，找到大小能**满足要求的第一个空闲分区**。

      

      进程6需要9M：

      ![image-20211225210812475](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225210812475.png)

      

      分配后：

      > 始终保持分区容量递增

      ![image-20211225210850261](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225210850261.png)

      

      **缺点：**

      ![image-20211225211154425](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225211154425.png)

      

   3. **最坏适应算法**

      ![image-20211225211304386](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225211304386.png)

      

      此时进程需要3M：

      ![image-20211225211350585](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225211350585.png)

      

      **分配后：**

      

      > 始终要保持分区容量递减

      ![image-20211225211510175](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225211510175.png)

      

      **缺点**：

      ![image-20211225211733371](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225211733371.png)

      

   4. **邻近适应算法**

   ![image-20211225211928406](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225211928406.png)

   

   进程需要5M:

   ![](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225212244696.png)

   

   **分配后**：

   > 之后就在**上次查找结束的位置**再开始查找满足需求的第一个空闲分区

   ![image-20211225212339915](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225212339915.png)

   **缺点**：

   ![image-20211225212812089](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225212812089.png)

   

   **四种算法对比**：

   ![image-20211225213149934](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225213149934.png)

   

3. 如何进行分区的分配与回收操作？

> 空闲分区表和空闲分区链差不多



分配：

1. 进程的大小小于空闲分区表要分配的分区大小，那么该分区还会存在并且一些参数会发生变化

   ![image-20211225191144685](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225191144685.png)

2. 进程的大小等于空闲分区表中要分配的分区大小，那么该分区将会在空闲分区表中删除

![image-20211225191214740](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225191214740.png)





**回收：**

1. 回收区的前/后面有一/多个相邻的空闲分区

   > 两个相邻的空闲分区合并为一个

   ![image-20211225192706992](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225192706992.png)





2. 回收区的前、后都没有相邻的空闲分区

![image-20211225192731274](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225192731274.png)



**注意：**

> 紧凑是指可以让内存中的进程移位，拼出更大的连续空闲空间

![image-20211225194315963](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211225194315963.png)

#### 3.2.2.2	非连续分配管理方式





**连续分配缺点：**

> 固定分区会产生内部碎片，动态分区会产生外部碎片，归根到底是因为需要给进程分配连续的空间。因此就引出了非连续分配管理方式



##### 3.2.2.2.1	基本分页存储管理

![image-20211226142637061](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226142637061.png)

![image-20211226142707554](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226142707554.png)



**如图：**

![image-20211226142730881](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226142730881.png)













**如何实现逻辑地址到物理地址的转换？**

![image-20211226142941213](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226142941213.png)







​	![image-20211226143800814](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226143800814.png)





**如何计算？**



![image-20211226144301096](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226144301096.png)





**为什么页面大小一般设为2的整数幂？**

![image-20211226145055749](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226145055749.png)



![image-20211226145322332](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226145322332.png)





**如何知道页号对应页面在内存中的起始地址？**



![image-20211226150016492](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226150016492.png)

![image-20211226151856476](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226151856476.png)







###### 3.2.2.2.1.1	基本地址变换机构

​	

> 用于实现逻辑地址到物理地址转换的一组硬件机构



**过程：**



![image-20211226163327163](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226163327163.png)



![image-20211226163836873](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226163836873.png)



![image-20211226163343486](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226163343486.png)





**例题：**

![image-20211226170601956](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226170601956.png)



![image-20211226172931122](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211226172931122.png)







###### 3.2.2.2.2.2	具有快表的地址变换机构



**局部性原理**：



> 时间局部性和空间局部性加起来称为局部性原理

![image-20211227100155938](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227100155938.png)





**快表**：

> 快表，又称联想寄存器（TLB），是一种**访问速度比内存块很多的高速缓冲存储器**，用来存放当前访问的若干页表项，**以加速地址变换的过程**。与此对应，**内存中的页表常称为慢表。**





**引入快表后，地址的变换过程：** 





![image-20211227100636576](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227100636576.png)



![image-20211227100448372](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227100448372.png)



> 由于查询快表的速度比查询页表中的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可达到90%以上



**例题**：

![image-20211227100849368](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227100849368.png)





**基本地址变换机构和具有快表的地址变换机构对比**：

![image-20211227101019475](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227101019475.png)





###### 3.2.2.2.2.3	两级页表



**单级页表存在的问题？**



> 当面临要分配多个连续的页框来存储页表就很乏力了



![image-20211227102223168](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102223168.png)

![image-20211227102047955](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102047955.png)



**如何解决**？



**问题一的解决方案**：

![image-20211227102255769](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102255769.png)





**问题二的解决方案**：



![image-20211227102855218](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102855218.png)



**两级页表的原理、地址结构**：



![image-20211227102550564](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102550564.png)

![image-20211227102615227](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102615227.png)





**如何实现地址变换**？



![image-20211227102727659](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102727659.png)



**两级页表问题需要注意的几个细节**？



![image-20211227102941115](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227102941115.png)







##### 3.2.2.2.2	基本分段存储管理



###### 3.2.2.2.2.1	 分段



> 分段：是按照程序自身逻辑划分的

![image-20211227195703822](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227195703822.png)



![image-20211227195619189](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227195619189.png)







###### 3.2.2.2.2.1	 段表



![image-20211227200516367](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227200516367.png)



###### 3.2.2.2.2.1	 如何实现地址变换

![image-20211227200225235](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227200225235.png)



**过程**：



![image-20211227200410220](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227200410220.png)



###### 3.2.2.2.2.1	 分段/分页管理的对比





![image-20211227201036136](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227201036136.png)





![image-20211227201346335](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227201346335.png)





![image-20211227201448319](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227201448319.png)



![image-20211227201541646](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227201541646.png)







**整体：**



![image-20211227201611366](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227201611366.png)





##### 3.2.2.2.3	段页式存储管理



**分页/分段管理的优缺点：**



![image-20211227202013620](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227202013620.png)



**段页式管理**：



> 段页式管理=分段+分页



![image-20211227202312901](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227202312901.png)





**逻辑地址结构：**

![image-20211227202500761](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227202500761.png)





**段表、页表：**

![image-20211227202625660](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227202625660.png)





**如何实现地址变换：**



**过程**：

![image-20211227202733880](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227202733880.png)





**体系结构：**

![image-20211227202845012](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227202845012.png)





### 3.2.3	虚拟内存的基本概念



**传统存储管理方式的特征、缺点：**

![image-20211227221455392](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211227221455392.png)







**高速缓冲技术的思想**：

> 将**近期会频繁访问到的数据放到更高速的存储器中**，**暂时用不到的数据放在更低速存储器中**。



#### 3.2.3.2	虚拟内存的定义和特征



![image-20211228185551275](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228185551275.png)



**三个特征**：



![image-20211228185741431](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228185741431.png)





#### 3.2.3.3	如何实现虚拟内存技术



![image-20211228190738877](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228190738877.png)



**梳理**：

![image-20211228191122758](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228191122758.png)



##### 3.2.3.3.1	请求分页存储管理



![image-20211228191539938](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228191539938.png)



###### 3.2.3.3.1.1	页表机制



![image-20211228192253518](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228192253518.png)



###### 3.2.3.3.1.2	缺页中断机构



![image-20211228192725546](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228192725546.png)



> 有空闲块则直接为进程分配一个空闲块并将所缺页面装入该块，并修改对应页表项

![image-20211228192800303](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228192800303.png)



> 没有空闲块，则执行页面置换算法选择一个页面淘汰
>
> ![image-20211228193227555](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228193227555.png)



![image-20211228193520625](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228193520625.png)



###### 3.2.3.3.1.3	地址变换机构



![image-20211228195624334](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228195624334.png)





![image-20211228200110632](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228200110632.png)



![image-20211228200121793](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228200121793.png)







**补充**：

![image-20211228200709268](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228200709268.png)





**梳理**：



![image-20211228200922632](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228200922632.png)





##### 3.2.3.3.2	页面置换算法



###### 3.2.3.3.2.1	最佳置换算法（OPT）



> 图里是否缺页指的是是否发生缺页中断

![image-20211228203154987](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228203154987.png)



**注意**：

![image-20211228203300526](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228203300526.png)



###### 3.2.3.3.2.2	先进先出置换算法（FIFO）



**算法思想**：

![image-20211228203758632](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228203758632.png)





![image-20211228204104514](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228204104514.png)



###### 3.2.3.3.2.3	最近最久未使用置换算法（LRU）



**思想**：

![image-20211228204550824](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228204550824.png)





**例题**：

![image-20211228204702060](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228204702060.png)



**缺点**：

![image-20211228204947912](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228204947912.png)



###### 3.2.3.3.2.4	时钟置换算法（CLOCK）



**算法思想**：



![image-20211228205450483](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228205450483.png)





**例题**：

![image-20211228205802066](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228205802066.png)



第一轮扫描完后页面的访问位都变为0，这时指针指向1号页，因此将1号页换出，6号页换入到1号页的位置，指针移动，页面访问位加一时不需要移动指针

![image-20211228205942387](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228205942387.png)





**最终结果**：

![image-20211228210050292](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228210050292.png)



###### 3.2.3.3.2.5	改进型的时钟置换算法



**思想**：



![image-20211228210933571](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228210933571.png)



**算法规则**：

![image-20211228213058603](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228213058603.png)





**经历四轮扫描的例子（其他的一样）：**	

![image-20211228211846127](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228211846127.png)



> 第一轮找（0,0）找不到也不修改任何标志位

![image-20211228211846127](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228211846127.png)



> 第二轮找（0,1）访问过的访问位设为0

![image-20211228212032563](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228212032563.png)



> 第三轮找（0,0），找不到也不修改任何标志位

![image-20211228212032563](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228212032563.png)



> 第四轮找（0,1），找到后进行淘汰页面

![image-20211228212314673](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228212314673.png)





###### 3.2.3.3.2.6	五种算法对比

![image-20211228213246093](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211228213246093.png)





##### 3.2.3.3.3	页面分配策略



###### 3.2.3.3.3.1	页面分配、置换策略



**驻留集**：

> 指请求分页存储管理中给进程分配的物理块的集合。
>
> **注意：**
>
> 1. 在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。
> 2. 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少
> 3. 若驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。



**固定分配、可变分配：**



![image-20211229125749872](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229125749872.png)



**局部置换、全局置换：**



![image-20211229125840335](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229125840335.png)



![image-20211229130722494](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229130722494.png)





**何时调入页面：**



![image-20211229132258903](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229132258903.png)



**从何处调入页面**：

![image-20211229133606215](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229133606215.png)



**抖动**：

![image-20211229133744293](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229133744293.png)





**工作集**：

> 指在某段时间间隔里，进程实际访问页面的集合。

![image-20211229134244230](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229134244230.png)



**梳理**：

![image-20211229134540217](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229134540217.png)









---



# 四、文件管理



## 4.1	整体结构



**文件**：

> 就是一组有意义的信息/数据集合



**文件如何放到外存**?

![image-20211229152957348](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229152957348.png)



**梳理**：

![image-20211229153328662](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229153328662.png)





## 4.2	文件的逻辑结构



### 4.2.1	无结构文件



![image-20211229154046574](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229154046574.png)



![image-20211229154056565](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229154056565.png)





### 4.2.2	有结构文件的逻辑结构



![image-20211229154741237](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229154741237.png)





**可变长记录**：

![image-20211229154925708](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229154925708.png)





#### 4.2.2.1	顺序文件



![image-20211229185938272](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229185938272.png)



![image-20211229190016140](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229190016140.png)





![image-20211229190730357](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229190730357.png)





#### 4.2.2.2	索引文件



![image-20211229211252464](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229211252464.png)



**缺点**：

![image-20211229211431312](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229211431312.png)





#### 4.2.2.3	 索引顺序文件



![image-20211229212704307](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229212704307.png)



**检索效率分析**：

![image-20211229213533849](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229213533849.png)



**多级索引顺序文件**：

![image-20211229213728071](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229213728071.png)



**梳理**：

![image-20211229213832351](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229213832351.png)



![image-20211229214012084](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211229214012084.png)









## 4.3 文件目录





### 4.3.1	文件控制块



> 文件目录项就是一个文件控制块

![image-20211230133217940](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230133217940.png)





### 4.3.2	目录结构



#### 4.3.2.1	单级目录结构



![image-20211230133656354](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230133656354.png)





#### 4.3.2.2	两级目录结构



![image-20211230134314636](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230134314636.png)





#### 4.3.2.3	多级目录



![image-20211230135708838](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230135708838.png)



![image-20211230135718768](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230135718768.png)



![image-20211230140012645](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230140012645.png)



**缺点**：

![image-20211230140059826](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230140059826.png)



#### 4.3.2.4	无环图目录结构



![image-20211230140904962](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230140904962.png)

![image-20211230141005653](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230141005653.png)



#### 4.3.2.5	索引结点



> 提升文件检索效率

![image-20211230141435268](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230141435268.png)

![image-20211230141627437](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230141627437.png)





**梳理**：

![image-20211230141823655](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230141823655.png)







## 4.4	文件的物理结构



> 文件的物理结构研究的是文件数据应怎样存放在外存



![image-20211230143447414](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230143447414.png)





![image-20211230143825385](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230143825385.png)





### 4.4.1	连续分配



![image-20211230144756534](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230144756534.png)





**连续分配的优点**：

![image-20211230145906201](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230145906201.png)





**缺点**：

1. 不方便拓展

![image-20211230150250536](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230150250536.png)





2. 会产生难以利用的磁盘碎片

![image-20211230150437391](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230150437391.png)





### 4.4.2	链接分配



> 链接分配可以为文件分配离散的磁盘块



#### 4.4.2.1	隐式链接



![image-20211230151031864](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230151031864.png)



**优点**：

> 方便文件拓展，不会有碎片问题，外存利用率高 



#### 4.4.2.2	显示链接



![image-20211230155020508](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230155020508.png)



> 可以随机存储是因为它可以通过文件分配表一个个去查，并不需要像隐式存储那样找到磁盘块之后再找下一块直到找到目标磁盘块为止

![image-20211230155736255](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230155736255.png)



![image-20211230160117281](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230160117281.png)





### 4.4.3	索引分配



![image-20211230170730560](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230170730560.png)





![image-20211230170959016](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230170959016.png)





**一个磁盘块装不下一个索引表怎么办**?



![image-20211230171359623](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230171359623.png)





#### 4.4.3.1	链接方案



![image-20211230172024708](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230172024708.png)





#### 4.4.3.2	多层索引



![image-20211230172707086](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230172707086.png)





#### 4.4.3.3	混合索引



![image-20211230173444050](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230173444050.png)





### 4.4.4	总结



![image-20211230173832716](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230173832716.png)





**梳理**：

![image-20211230174026461](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230174026461.png)





## 4.5	文件存储空间管理





### 4.5.1	存储空间的划分与初始化



![image-20211230180556376](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230180556376.png)





### 4.5.2	几种管理方法



#### 4.5.2.1	空闲表法



![image-20211230181012673](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230181012673.png)



![image-20211230181025742](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230181025742.png)



**回收空闲的磁盘块**：



![image-20211230181631110](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230181631110.png)

![image-20211230181544594](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230181544594.png)



![image-20211230181608744](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230181608744.png)





#### 4.5.2.2	空闲链表法

![image-20211230182554085](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230182554085.png)



##### 4.5.2.2.1	空闲盘块链



![image-20211230182721367](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230182721367.png)



##### 4.5.2.2.2	空闲盘区链



![image-20211230183048566](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230183048566.png)



#### 4.5.2.3	位示图法



![image-20211230183845212](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230183845212.png)







![image-20211230184039368](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230184039368.png)





#### 4.5.2.4	成组链接法



![image-20211230184218771](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230184218771.png)



> 分组中的第一个空闲盘块号还要记录下一组空闲盘块的信息



![image-20211230184755683](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230184755683.png)



![image-20211230185738087](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230185738087.png)



![image-20211230185746377](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230185746377.png)



**回收**：



**分组没满**：

> 插入到没满分组的后面，并修改空闲盘块数量

![image-20211230190056369](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230190056369.png)



**分组满了**：

​	![image-20211230190234273](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230190234273.png)





**梳理**：

![image-20211230190534222](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230190534222.png)







## 4.6	文件的基本操作



![image-20211230203821663](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230203821663.png)

![image-20211230204236177](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230204236177.png)



![image-20211230205350219](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230205350219.png)



![image-20211230205813754](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230205813754.png)



![image-20211230211328397](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230211328397.png)



![image-20211230211859473](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230211859473.png)



![image-20211230212252461](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211230212252461.png)









## 4.7	文件链接



![image-20211231130612374](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231130612374.png)



### 4.7.1	硬链接



![image-20211231130427919](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231130427919.png)



![image-20211231130524754](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231130524754.png)





### 4.7.2	软链接



![image-20211231130811183](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231130811183.png)





**梳理**：

![image-20211231131352390](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231131352390.png)



## 4.8	文件保护



### 4.8.1	口令保护



![image-20211231131814015](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231131814015.png)



### 4.8.2	加密保护



> 对文件的原始数据进行加密操作



![image-20211231132310490](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231132310490.png)







### 4.8.3	访问控制



![image-20211231132520205](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231132520205.png)



![image-20211231132708589](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231132708589.png)



**梳理**：

![image-20211231133721781](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231133721781.png)







# 五、磁盘



## 5.1 磁盘的结构



![image-20211231193117396](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231193117396.png)





**如何读写数据**：

![image-20211231193428293](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231193428293.png)



**读取外存中磁盘块的数据**：

![image-20211231193818581](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231193818581.png)



**磁盘的分类**：



![image-20211231193922150](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231193922150.png)



**梳理**：

![image-20211231194102448](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231194102448.png)





## 5.2	磁盘调度算法



一次磁盘读/写操作的时间为：

> 寻道时间+延迟时间+传输时间

![image-20211231194826729](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231194826729.png)



![image-20211231195022707](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231195022707.png)

![image-20211231195032972](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231195032972.png)





### 5.2.1	先来先服务算法（FCFS）



![image-20211231201722864](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231201722864.png)





### 5.2.2	最短寻找时间优先（SSTF）

![image-20211231202627205](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231202627205.png)



### 5.2.3	扫描算法（SCAN）



![image-20211231203404437](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231203404437.png)



### 5.2.4	LOOK调度算法



![image-20211231203613400](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231203613400.png)





### 5.2.5	循环扫描算法（C-SCAN）



![image-20211231204025987](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231204025987.png)



### 5.2.6	C-LOOK调度算法

![image-20211231204226958](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231204226958.png)



**梳理**：

![image-20211231204704479](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231204704479.png)





## 5.3	减少磁盘的延迟时间方法





![image-20211231205041533](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231205041533.png)



**方法**：

![image-20211231205643478](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231205643478.png)



**梳理**：

![image-20211231210855511](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231210855511.png)



## 5.4	磁盘的管理



### 5.4.1	磁盘初始化

![image-20211231211338241](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20211231211338241.png)







---



# 六、设备管理





## 6.1	I/O设备的基本概念



![image-20220101153903919](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220101153903919.png)





![image-20220101154047145](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220101154047145.png)

![image-20220101154031756](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220101154031756.png)







## 6.2	IO控制器

![image-20220101154325883](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220101154325883.png)



![image-20220101154427935](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220101154427935.png)



![image-20220101154823944](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220101154823944.png)





![image-20220102152247631](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102152247631.png)



![image-20220102152434522](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102152434522.png)



![image-20220102152632189](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102152632189.png)



**梳理**：

![image-20220102152729826](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102152729826.png)





## 6.3	I/O控制方式



![image-20220102153039642](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102153039642.png)





### 6.3.1	程序直接控制方式



![image-20220102154333591](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102154333591.png)





![image-20220102160201498](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102160201498.png)







### 6.3.2	中断驱动方式



![image-20220102160802650](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102160802650.png)





![image-20220102161009665](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102161009665.png)





### 6.3.3	DMA方式





![image-20220102161553658](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102161553658.png)





DMA**控制器的介绍**：

![image-20220102162114895](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102162114895.png)



![image-20220102162340618](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102162340618.png)



### 6.3.4	通道控制方式

![image-20220102162728242](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102162728242.png)

> 通道程序由一系列通道指令组成
>
> 一个通道可以控制多个I/O控制器

![image-20220102162910695](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102162910695.png)







### 6.3.5	四种控制方式的对比

![image-20220102163153028](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102163153028.png)





## 6.4	I/O软件层次结构

![image-20220102163552354](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102163552354.png)



![image-20220102165315026](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102165315026.png)





## 6.5	I/O核心子系统

![image-20220102190010042](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102190010042.png)

![image-20220102190058453](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102190058453.png)

![image-20220102190113048](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102190113048.png)

  



## 6.6	假脱机技术



![image-20220102211018709](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211018709.png)



### 6.6.1	假脱机技术的实现原理



![image-20220102211555469](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211555469.png)

#### 6.6.1.1	输入井和输出井



![image-20220102211232483](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211232483.png)



![image-20220102211249492](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211249492.png)



#### 6.6.1.2	输入进程和输出进程



![image-20220102211352605](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211352605.png)



![image-20220102211358708](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211358708.png)







### 6.6.2	共享打印机的原理分析

![image-20220102211725880](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102211725880.png)



![image-20220102212023158](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102212023158.png)

![image-20220102212050789](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102212050789.png)





## 6.7	设备的分配与回收



![image-20220102222507223](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102222507223.png)



![image-20220102222605777](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102222605777.png)![image-20220102222842259](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102222842259.png)



![image-20220102223002235](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102223002235.png)



### 6.7.1	设备分配管理中的数据结构



![image-20220102223243925](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102223243925.png)



![image-20220102223434406](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102223434406.png)



![image-20220102223607258](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102223607258.png)

![image-20220102223711351](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102223711351.png)

![image-20220102223824558](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102223824558.png)



### 6.7.2	设备分配步骤

![image-20220102224353459](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102224353459.png)

![image-20220102224410708](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102224410708.png)



**设备分配步骤的改进**：

![image-20220102224811458](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102224811458.png)

![image-20220102224758163](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102224758163.png)



![image-20220102225031323](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102225031323.png)





## 6.8	缓冲区管理



![image-20220102225322960](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102225322960.png)



![image-20220102225903859](https://gitee.com/steadyHeart/drawingBed/raw/master/photos/image-20220102225903859.png)

### 6.8.1	单缓冲



### 6.8.2	双缓冲



### 6.8.3	循环缓冲



### 6.8.4	缓冲池

